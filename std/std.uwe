[basic functions]
id = \a a
then = \a \b \c b `id a c
combine-then = \a \b \c \d b `id a c d
const = \a \b a
rev = \a \b b a
revrev = \a \b rev a `then rev b
self-call = \a a a
recursive = \a self-call \b a `id b b
[bool]
true = const
false = 0
and = \a \b a b a
or = \a \b a a b
not = revrev false true
nand = and `combine-then not
nor = or `combine-then not
xor = \a \b or a b `and nand a b
xnor = xor `combine-then not
tostring-bool = revrev "true" "false"
[either]
left = \a \b const `id b a
right = \a \b \c c a
either-call = \a \b b a a
[maybe]
just = left
none = 0
maybe-call = rev `combine-then rev 0
[tuple]
,tup = \a \b \c c a b
head-tup = true
tail-tup = false
[list]
,list = ,tup `combine-then just
head-list = maybe-call head-tup
tail-list = maybe-call tail-tup
@list = \a \b head-list `id b tail-list a
reduce-list = recursive \self \f \base \list list (\head,tail self f (f base `id head-tup head,tail) `id tail-tup head,tail) base
filter-list = \f reduce-list (\l \elem (f elem) (l `,list elem) l) 0
map-list = \f reduce-list (\l \elem l `,list (f elem)) 0
+list = reduce-list ,list
[num]
++num = \a \b b `then a b
+num = rev ++num
*num = \a +num a `revrev 0
^num = rev
shift-incr-tup _= tail-tup `then \a a `,tup ++num a
--num = revrev shift-incr-tup (0 `,tup 0) `then head-tup
-num = rev --num
=0 = const false `revrev true
<=num = -num `combine-then =0
>num = <=num `combine-then not
=num = \a \b <=num a b `and <=num b a
>=num = \a \b =num a b `or >num a b
<num = >=num `combine-then not
[TODO more num things]
[io]
inp = left `then left
otp = right `then left
fork = just `then right
stop = right false
