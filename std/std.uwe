[basic functions]
id = \a a
then = \a \b \c b `id a c
combineThen = \a \b \c \d b `id a c d
const = \a \b a
rev = \a \b b a
revRev = \a \b rev a `then rev b
selfCall = \a a a
recursive = \a selfCall \b a `id b b
[Bool]
true = const
false = 0
and = \a \b a b a
or = \a \b a a b
not = revRev false true
nand = and `combineThen not
nor = or `combineThen not
xor = \a \b or a b `and nand a b
xnor = xor `combineThen not
Bool->String = revRev "true" "false"
[Either]
left = \a \b const `id b a
right = \a \b \c c a
call_Either = \a \b b a a
[Maybe]
just = left
none = 0
call_Maybe = \a revRev (a `then just) none
[Tup]
,T = \a \b \c c a b
head_Tup = rev true
tail_Tup = rev false
[List]
,L = ,T `combineThen just
head_List = call_Maybe head_Tup
tail_List = call_Maybe tail_Tup `then revRev id 0
Maybe->List = call_Maybe \a a `,T 0
@List = \a \b head_List `id b tail_List a
push_List = recursive \self \elem revRev (\head,tail head_Tup head,tail `,L self elem `id tail_Tup head,tail) `id elem `,L 0
reduce_List = recursive \self \f \base \list list (\head,tail self f (f (head_Tup head,tail) base) `id tail_Tup head,tail) base
reverse_List = reduce_List ,L 0
filter_List = \f reduce_List (\elem \l (f elem) (elem `push_List l) l) 0
map_List = \f reduce_List (\elem \l f elem `push_List l) 0
+List = reduce_List push_List
[Num]
++Num = \a \b b `then a b
+Num = rev ++Num
*Num = \a +Num a `revRev 0
^Num = rev
shiftIncr_Tup _= tail_Tup `then \a a `,T ++Num a
--Num = revRev shiftIncr_Tup (0 `,T 0) `then head_Tup
-Num = revRev --Num
=0 _= const false `revRev true
<=Num = -Num `combineThen =0
>Num = <=Num `combineThen not
=Num = \a \b <=Num a b `and <=Num b a
>=Num = \a \b =Num a b `or >Num a b
<Num = >=Num `combineThen not
/Num = \a \b rev 0 `id recursive \self \n (*Num b n `>Num a) (--Num n) `id self `id ++Num n
%Num = \a \b a `-Num b `*Num a `/Num b
Num->String = rev true `id recursive \self \isFirstDigit \n (=0 n) (isFirstDigit "0" "") `id self false (n `/Num 10) `+List Maybe->List `id "0123456789" `@List n `%Num 10
[IO]
inp = left `then left
otp = ,T `combineThen right `then left
fork = ,T `combineThen just `then right
stop = right false
[Types]
T = left
-> = ,T `combineThen right
id : T 0 `-> T 0
Num = (T 0 `-> T 0) `-> T 0 `-> T 0
++Num : Num `-> Num
[type declarations for half the things don't work yet...]
